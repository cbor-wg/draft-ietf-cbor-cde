{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-11T01:40:03.736634+00:00",
  "repo": "cbor-wg/draft-ietf-cbor-cde",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "On Explainer Document",
      "description": "",
      "color": "f9d0c4"
    },
    {
      "name": "to be closed",
      "description": "",
      "color": "333333"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJ8fYd85vANwe",
      "title": "det: more use cases",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/1",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "On Explainer Document"
      ],
      "body": "Use Wolf's list of use cases <https://mailarchive.ietf.org/arch/msg/cbor/RaZfA5XLMRQ65kKu_XstEPwMK2k>\r\nto generate a more complete list in det.",
      "createdAt": "2023-08-22T23:26:34Z",
      "updatedAt": "2025-05-01T08:21:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOJ8fYd85vJJEG",
      "title": "det: Add pseudocode for preferred encoding and numeric reduction",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/2",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "On Explainer Document"
      ],
      "body": "",
      "createdAt": "2023-08-24T08:28:54Z",
      "updatedAt": "2025-05-01T08:22:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hildjj",
          "authorAssociation": "NONE",
          "body": "Is this issue overcome by events?",
          "createdAt": "2024-01-24T19:35:00Z",
          "updatedAt": "2024-01-24T19:35:00Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "I do think that we want to have some such pseudocode.\r\nThe question is whether it belongs into the normative document for CDE or in the determinism explainer (\"det\").\r\nWe also haven't decided on any role that the explainer could play in the WG.",
          "createdAt": "2024-01-25T12:57:12Z",
          "updatedAt": "2024-01-25T12:57:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Given some aversion against adding more implementation help to the BCP, I would keep this as a TODO on the explainer document.",
          "createdAt": "2025-05-01T08:22:44Z",
          "updatedAt": "2025-05-01T08:22:44Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJ8fYd85vJLtU",
      "title": "terminology: f16, float16, binary16",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/3",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do not mix up these terms:\r\n\r\n* f16 (Rust name for a platform level storage type),\r\n* float16 (CDDL name for a floating point precision and range), and \r\n* binary16 (IEEE 754 name for a binary representation of floating point values).\r\n\r\n(and 32, 64).",
      "createdAt": "2023-08-24T08:35:49Z",
      "updatedAt": "2024-01-25T12:54:17Z",
      "closedAt": "2024-01-25T12:54:17Z",
      "comments": [
        {
          "author": "hildjj",
          "authorAssociation": "NONE",
          "body": "Is this issue overcome by events?",
          "createdAt": "2024-01-24T19:34:41Z",
          "updatedAt": "2024-01-24T19:34:41Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "CDE currently doesn't mention these different concepts.\r\nThe explainer does, but I don't find any place that needs immediate attention.\r\n(Obviously, we want to keep the principle in mind.)",
          "createdAt": "2024-01-25T12:54:17Z",
          "updatedAt": "2024-01-25T12:54:17Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJ8fYd8553fNd",
      "title": "additional information in integers vs doubles",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/4",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the section on reducing floating point numbers to integers, I believe it would be appropriate to clearly specify behavior of other floating point reductions, e.g. reducing 0.5 from double to a half-width float.\r\n\r\nIn addition, I believe the behavior needs to be defined as to what an application should do when conversion of an integer to a floating point number is in itself lossy, e.g. what to do if an application expects a double but the CBOR value received is the decimal 9007199254740993. Silent truncation would make the round-trip non-deterministic.",
      "createdAt": "2023-12-16T03:42:40Z",
      "updatedAt": "2024-10-16T10:57:40Z",
      "closedAt": "2024-10-16T10:57:40Z",
      "comments": [
        {
          "author": "hildjj",
          "authorAssociation": "NONE",
          "body": "See the section on [preferred serialization](https://www.rfc-editor.org/rfc/rfc8949.html#name-preferred-serialization) in RFC8949, and read the dCBOR [draft](https://www.ietf.org/archive/id/draft-mcnally-deterministic-cbor-07.html), then see what else this spec needs?",
          "createdAt": "2024-01-24T19:33:40Z",
          "updatedAt": "2024-01-24T19:33:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Additional information about the use of numbers in CBOR has been captured in https://www.ietf.org/archive/id/draft-bormann-cbor-numbers-00.html -- I believe if we need any additional discussion of this, that should go there.",
          "createdAt": "2024-10-16T10:57:40Z",
          "updatedAt": "2024-10-16T10:57:40Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJ8fYd859MRmz",
      "title": "CDE: More explicitly disallow equivalent map keys",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/6",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Make the requirement that a CDE-encoded data item does not contain duplicate (or equivalent) keys in its maps more explicit.\r\n\r\nArchived-At: <https://mailarchive.ietf.org/arch/msg/cbor/bRgglMTgXsdpkKvxToNSjLt4-Qo>\r\n",
      "createdAt": "2024-01-25T13:08:08Z",
      "updatedAt": "2024-07-08T23:40:53Z",
      "closedAt": "2024-07-08T23:40:53Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOJ8fYd86BE0uZ",
      "title": "Terminology: preferred serialization or preferred encoding",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/8",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"preferred serialization\" (lower case) is used 23 times in RFC 8949.\r\n\r\n\"preferred encoding\" (lower case) is used once parenthetically in RFC 8949.\r\n\r\nThis draft uses \"preferred encoding\" (upper and lower case) 6 times.\r\n\r\nThis draft uses \"preferred serialization\" once, plus some use in PRs.\r\n\r\nProbably this draft should exclusively use \"preferred serialization\" in lower case. We did a go around in RATS/EAT about upper/lower case and even though RATS architecture uses upper case, EAT switched to lower case as much more readable.",
      "createdAt": "2024-03-03T19:40:47Z",
      "updatedAt": "2024-03-03T20:17:53Z",
      "closedAt": "2024-03-03T20:17:53Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOJ8fYd86PeNE_",
      "title": "Remove Application Profiles",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/14",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Application Profiles seem like an unnecessary complexity to me in an area that (I think) we're trying to make simpler.\r\n\r\nI look at this draft as a really useful rewording of some important stuff in section 4 and 5 of RFC 8949. Those sections of 8949 are a bit complicated for readers, so this draft should be simple.\r\n\r\nSo far the only proposed profile is dCBOR. I think dCBOR exists just fine without the notion of application profiles, just like CDE exists just fine on top of preferred serialization.\r\n\r\nTo justify the complexity application profiles add, I think we'd want to have three solid use cases for them.\r\n\r\nApplication profiles are only for variations of CDE. They are not for variations of preferred serialization or a general profile mechanism for all of CBOR. This makes them much much less useful.",
      "createdAt": "2024-07-13T17:12:03Z",
      "updatedAt": "2024-11-03T16:15:48Z",
      "closedAt": "2024-11-03T16:15:48Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you explain how giving the concept a name adds complexity?\r\n",
          "createdAt": "2024-07-14T05:04:15Z",
          "updatedAt": "2024-07-14T05:04:15Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "Doesn't the burden of justification for something in a document lie with the proponent of the something?\r\n\r\nA short answer to your question is that for us careful implementors every concept in a document must be read, digested, thought through and understood to be sure of correctness and completeness.\r\n\r\nBut, I don't think things should go in documents unless there is justification.",
          "createdAt": "2024-07-14T18:58:59Z",
          "updatedAt": "2024-07-14T18:58:59Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Of course.  The most recent mail where I tried to explain the reason for them is Archived-At: <https://mailarchive.ietf.org/arch/msg/cbor/7CAgHZxvj34Rf4rcXFGeFwBzv_M>\r\n\r\nTo make a decision, it is necessary not only to understand the benefit, but also the cost of the feature.\r\nTo me it seems it creates zero cost for those who do not implement it.\r\nIf you think you do not need it, I would not implement it.\r\n",
          "createdAt": "2024-07-14T19:17:08Z",
          "updatedAt": "2024-07-14T19:17:08Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "I don't see how the cost is zero. You have to understand it to know that you don't have to implement it.\r\n\r\nThere's a cost to protocol designers too. They have to understand it to know whether they should use it or not use it.\r\n\r\nThere's also some cost to the WG, the IESG and the RFC editor to review.\r\n",
          "createdAt": "2024-07-14T19:23:50Z",
          "updatedAt": "2024-07-14T19:23:50Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "We could improve the text to make this easier to understand.\r\n\r\nThe cost of *not* having the feature is immense.\r\nPeople will notice that their application data model does not map one-to-one to CDE and will do exactly what dCBOR did in the outset -- reinvent a incompatible variant of CDE because their application data model isn't identical to the generic data model of CBOR.\r\n\r\nSo it is absolutely worth massive effort to have application profiles as a concept in place.\r\nI still believe the actual effort is minimal, and I would like to understand what text in CDE creates complexity for you, and how we could minimize the discovery cost for those whose actual cost is zero because they don't need it.",
          "createdAt": "2024-07-14T20:31:59Z",
          "updatedAt": "2024-07-14T20:33:02Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "The justification I am looking for is the description of some more compelling use cases to sit along side dCBOR. I don't think any have been described.\r\n\r\nI don't see immensity here. If there was immensity, then there would be at least a couple of examples of bad variants of CDE. So far we only have one variant of CDE which IMO isn't too bad (other opinions aside).\r\n\r\nAlso, can you say why application profiles are justified for CDE, but not preferred serialization or a general profile mechanism for all of CBOR?",
          "createdAt": "2024-07-15T19:27:18Z",
          "updatedAt": "2024-07-15T19:27:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #15 should address most of your concerns, without removing the concept of Application Profiles entirely.",
          "createdAt": "2024-07-16T19:24:40Z",
          "updatedAt": "2024-07-16T19:24:40Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "While moving to an appendix is an improvement, I still would like to see application profiles removed. I was waiting for the meeting on Friday before completing the review.",
          "createdAt": "2024-07-24T17:50:13Z",
          "updatedAt": "2024-07-24T17:50:13Z"
        },
        {
          "author": "cyberphone",
          "authorAssociation": "NONE",
          "body": "1. Currently CBOR support (=profiles) is _implicitly_ or _explicitly_ specified as a part of applications and implementations. Deterministic encoding does IMO not motivate a change.\r\n\r\n2. Referencing dCBOR indirectly transcends Numeric Reduction into an \"IETF-standardized\" encoding method, although dCBOR was rejected as a WG item.  The dCBOR spec. can refer to CBOR-CDE without the application profile concept in the same way as CBOR-CDE refers to RFC 8949.\r\n",
          "createdAt": "2024-10-05T06:06:26Z",
          "updatedAt": "2024-10-05T06:06:26Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJ8fYd86QVoxX",
      "title": "Implementation checks require definite length when that is actually not required",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/17",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 2 has this right, items 2 and 3 of B.1.1 don\u2019t.\r\n",
      "createdAt": "2024-07-21T20:33:19Z",
      "updatedAt": "2024-07-25T23:48:02Z",
      "closedAt": "2024-07-25T23:48:02Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOJ8fYd86Qvw9H",
      "title": "Inconsistent language about what to do when checks fail",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/18",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Archived-At: <https://mailarchive.ietf.org/arch/msg/cbor/IwZBL1Q522pZA3pIJfo5WJ0YVtY>\r\n",
      "createdAt": "2024-07-24T20:45:16Z",
      "updatedAt": "2024-11-03T16:15:48Z",
      "closedAt": "2024-11-03T16:15:48Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's check whether the changes in #19 suffice and we can close this",
          "createdAt": "2024-07-25T23:49:04Z",
          "updatedAt": "2024-07-25T23:49:04Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOJ8fYd86YPmhz",
      "title": "Be more explicit that CDE does not require (or include) Unicode normalization (but application processing/profiles can).",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/20",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Archived-At: <https://mailarchive.ietf.org/arch/msg/cbor/UXFWzGU5gCHem50gTQSss-YCoc8>\r\n",
      "createdAt": "2024-09-28T13:36:07Z",
      "updatedAt": "2024-11-03T16:15:47Z",
      "closedAt": "2024-11-03T16:15:47Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOJ8fYd86d-XhT",
      "title": "ALDR Comments",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/22",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "My understanding is that in moving away from Application Profiles to ALDR, the notion that there are many *classes* of application that will layer on top of CDE is no longer. I think this is good. There's no eCBOR and fCBOR follow-ons to dCBOR, each of which has dozens of applications in each class. \r\n\r\nSo ALDR is primarily about application-specific rules now.\r\n\r\nA question is why do applications that use CDE have any more need for rules than applications that use preferred serialization or any sort of serialization.\r\n\r\nPreferred Serialization of big numbers requires *reduction* of the range of big numbers from -(2^64) through (2^64)-1 to integers. This is an example of an ALDR-like rule outside of CDE.\r\n\r\nSince this is about application-specific rules, I'd say that every application protocol excludes something, usually a lot. For example most protocols exclude floating-point just by not using it.\r\n\r\nDescribing the notion of a reduction seems useful for some applications that want an expanded notion of determinism past serialization into the data model. My preference would be to describe it as an application design consideration in an appendix titled \"Reductions\" or such.\r\n\r\nA lot of the description about reduction would be why they are useful for determinism in some contexts.\r\n\r\nA lot of the text in Appendix A is still oriented such that there is going to be an eCBOR, fCBOR,... I'd like to see that reoriented. I think the dCBOR document shouldn't refer to itself as a profile anymore.\r\n\r\nI don't think we need the concept of ALDR. We didn't need a conceptual name to write RFC 8949 section 5, \"Creating CBOR-Based Protocols\".",
      "createdAt": "2024-11-11T20:49:00Z",
      "updatedAt": "2025-05-01T08:27:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "Consider this text:  https://mailarchive.ietf.org/arch/msg/cbor/G6w0Rz0eW9GJNd1et8I899Ua9MQ/\n\nFor the appendix, per interim discussion today. cc @chrysn ",
          "createdAt": "2025-03-05T15:16:55Z",
          "updatedAt": "2025-03-05T15:16:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "> A question is why do applications that use CDE have any more need for rules than applications that use preferred serialization or any sort of serialization.\n\nWhere deterministic representation is an actual requirement (and not just a matter of taste as in Anders' documents), there always is a need for thinking about this at the application level.  Whether this leads to actual rules depends on the case, but having the explanation to point out this must be thought about, but is separate from the deterministic encoding, motivates a brief discussion.\n\nApart from this question, I think this issue is OBE based on the integration of text ideas Laurence supplied in the above-referenced.\n\nCan this be closed now?\n\n",
          "createdAt": "2025-05-01T08:27:41Z",
          "updatedAt": "2025-05-01T08:27:41Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOJ8fYd86vBCFy",
      "title": "Remove threat-based justification of ALDR",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/25",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "There's text that justifies the need for ALDR to defend a threat from wayward serialization schemes (e.g., from badly conceived  eCBOR, fCBOR and gCBOR). That threat doesn't really exist, so this text is unnecessary and confusing.\n\nIt's in several places in the document. not just the appendix.\n\nI think the main frame up for ALDR should be orient around helping designers of deterministic protocols. I think that's what the readers need.\n\n\n",
      "createdAt": "2025-03-20T18:09:56Z",
      "updatedAt": "2025-05-01T08:31:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hildjj",
          "authorAssociation": "NONE",
          "body": "Can you point to sections in the current version that you are worried about, so I'm sure I'm looking at the right places, please? ",
          "createdAt": "2025-04-02T14:22:29Z",
          "updatedAt": "2025-04-02T14:22:29Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "I cannot find the word \"threat\" in the current document, and the above question is unanswered.\n\n(Apart from that, his threat definitely exists, motivated by the toybox approach used by RFC 8949 Core DE Requirements; it is just exacerbated when people don't know about the architecture.)\n\nCan this be closed?",
          "createdAt": "2025-05-01T08:30:51Z",
          "updatedAt": "2025-05-01T08:30:51Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOJ8fYd86vBE-p",
      "title": "Add concrete ALDR recommendations for all data model items in RFC 8949",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/26",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/cbor/n1uFlXyT27vYHcnI4MnyzDjVCz0/\n\nI think these can replace the COSE thumbprint example. (I'm hoping for less text as well as clarity).\n\nI think this is important in that we should actually do what we say we people should do.",
      "createdAt": "2025-03-20T18:15:46Z",
      "updatedAt": "2025-05-03T12:08:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Most of this list is indeed useful, we could add this information to the examples in Appendix B.",
          "createdAt": "2025-05-01T08:33:06Z",
          "updatedAt": "2025-05-01T08:33:06Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "See also: <https://mailarchive.ietf.org/arch/msg/cbor/Lm-GYgTDUCESkBzSo3Ws02WBNFU>\n",
          "createdAt": "2025-05-03T12:08:47Z",
          "updatedAt": "2025-05-03T12:08:47Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOJ8fYd86wu4p9",
      "title": "CDE or CDE Profile?",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/29",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In RFC 8949 it is always \"Core Deterministic Encoding Requirements\"\n\nIn discussions we say \"CDE\"; I guess didn't happen to use \"CDER\"\n\nIn draft-cbor-cde it is sort renamed/magnified into \"CBOR Common Deterministic Encoding Profile\".\n\nThis is the sort multi-naming that causes a reader to spend an hour or two to figure out if they are the same or different. It's a lot harder for them to sort through this than us because they are likely coming in pretty cold and uninformed.\n\nThe requirements in RFC 8949 4.2.1 for CDE are pretty solid in my opinion. There's no need to rename because of a few clarifications. \n\nSo may be always \"Core Deterministic Encoding Requirements\" in long form and \"CDE\" in short?\n\n\n\n",
      "createdAt": "2025-04-02T03:29:30Z",
      "updatedAt": "2025-04-02T15:52:54Z",
      "closedAt": "2025-04-02T15:52:54Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Laurence,\r\n\r\n(Copying my response to the CBOR list.)\r\n\r\n> On 2. Apr 2025, at 05:29, Laurence Lundblade ***@***.***> wrote:\r\n> \r\n> In RFC 8949 it is always \"Core Deterministic Encoding Requirements\"\r\n\r\nYes.  This is how far we got with things up to 2020.\r\n\r\nThe idea in 7049 (2013) was that an application protocol would define its own \u201ccanonical encoding\u201d.\r\n\r\nSection 3.9 about application protocols that want to do that:\r\n\r\n   Those protocols are free to define\r\n   what they mean by a canonical format and what encoders and decoders\r\n   are expected to do.  This section lists some suggestions for such\r\n   protocols.\r\n\r\nSo 7049 essentially provided a toolkit that an application protocol would pick from to define its own canonical encoding; there was no normative intent to have a common one, but we did provide some suggestions for the application protocol \r\n\r\nIn 8949, we still had this approach, but started giving it some structure:\r\n\r\n   A CBOR encoding satisfies the \"core deterministic encoding\r\n   requirements\" if it satisfies the following restrictions:\r\n\r\nSo, still, the application protocol would essentially define a custom deterministic encoding; Section 4.2 still says:\r\n\r\n   Those\r\n   protocols are free to define what they mean by a \"deterministic\r\n   format\" and what encoders and decoders are expected to do.  This\r\n   section defines a set of restrictions that can serve as the base of\r\n   such a deterministic format.\r\n\r\nHence the term \"Core Deterministic Encoding Requirements\u201d \u2014 these were *requirements* an application protocol that wanted to be deterministic could adopt.  Or not adopt \u2014 everything was custom.\r\n\r\nWe have since made major progress:\r\nWe understand that the vast majority of the application protocols that want to be deterministic can use a \u201cCommon Deterministic Encoding\u201d (CDE), maybe with a topping of some ALDR rules.\r\nSo the CDE BCP picks all the details of the \u201cCommon Deterministic Encoding\u201d, no need for the application protocol to do anything except say \u201cusing CDE\u201d (plus possibly some ALDR rules).\r\nOf course, applications can still define their own deterministic encoding (4.2.3 of 8949 also is still around), but we have:\r\n\r\n    One\r\n\r\n\u201cCommon Deterministic Encoding\u201d.\r\n\r\nThe difference here is not so much in what details we picked, but in the normative intent of there being \r\n\r\n    One\r\n\r\n    \u201cCommon\r\n\r\nDeterministic encoding\".\r\n\r\n> In discussions we say \"CDE\"; I guess didn't happen to use \"CDER\"\r\n\r\nThe 2020 status was \"Core Deterministic Encoding Requirements\u201d (which could be abbreviated to CDER but better never is).\r\nThe 2023 status (on which we have been chewing for a couple years now) is that those requirements continue to be available for custom application protocols, but we have picked a best current practive, the\r\n\r\n     \u201cCommon\u201d\r\n\r\nDeterministic Encoding.\r\n\r\n> In draft-cbor-cde it is sort renamed/magnified into \"CBOR Common Deterministic Encoding Profile\".\r\n\r\nWe need to get rid of that last occurrence of \u201cprofile\u201d.\r\n\r\n> This is the sort multi-naming that causes a reader to spend an hour or two to figure out if they are the same or different.\r\n\r\nThe technicalities are the same, the *normative intent* is different, so it is really worthwhile to have a name for the new intent, even if there isn\u2019t that much technical innovation.\r\n\r\n> It's a lot harder for them to sort through this than us because they are likely coming in pretty cold and uninformed.\r\n> The requirements in RFC 8949 4.2.1 for CDE are pretty solid in my opinion. There's no need to rename because of a few clarifications.\r\n\r\nThere is a need to make clear we now have a \u201c*Common* Deterministic Encoding\u201d, not just a set of requirements that an application protocol needs to choose from (4.2.2).\r\n\r\n> So may be always \"Core Deterministic Encoding Requirements\" in long form and \"CDE\" in short?\r\n\r\nNo, that would be a major regression.\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n\r\n",
          "createdAt": "2025-04-02T04:11:41Z",
          "updatedAt": "2025-04-02T04:11:41Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJ8fYd86w1uyA",
      "title": "Relation to 8949",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/30",
      "state": "OPEN",
      "author": "OR13",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "\nSTD94 -> [4.2.1. ](https://datatracker.ietf.org/doc/html/rfc8949#section-4.2.1)[Core Deterministic Encoding Requirements](https://datatracker.ietf.org/doc/html/rfc8949#name-core-deterministic-encoding)\n\nCDE BCP draft -> [CBOR Common Deterministic Encoding (CDE)](https://datatracker.ietf.org/doc/html/draft-ietf-cbor-cde-10#name-cbor-common-deterministic-e)\n\n> This specification defines the CBOR Common Deterministic Encoding (CDE) based on the Core Deterministic Encoding Requirements defined for CBOR in Section [4.2.1](https://rfc-editor.org/rfc/rfc8949#section-4.2.1) of RFC 8949 [[STD94](https://www.rfc-editor.org/info/std94)].\n\n\nThis makes it clear that \"CBOR Common Deterministic Encoding \" builds on \"Core Deterministic Encoding Requirements\".\n\nLater:\n\n> CDE turns this recommendation into a mandate: Integers that can be represented by basic major type 0 and 1 are encoded using the deterministic encoding defined for them, and integers outside this range are encoded using the preferred serialization (Section [3.4.3](https://rfc-editor.org/rfc/rfc8949#section-3.4.3) of RFC 8949 [[STD94](https://www.rfc-editor.org/info/std94)]) of tag 2 and 3 (i.e., no leading zero bytes).\n\nLogically, this is turning a SHOULD, into a MUST.\n\nI think we agree on what is happening here, and the layering, and even ALDR.\n\nWhere we seem to not have agreement in discussing this, is on clarity of terminology, and to a certain degree, on what the problem is we are solving with the BCP.\n\nMy understanding of the problem is as follows:\n\nPeople and SDOs believe that CBOR has no interoperable deterministic encoding.\nPeople and SDOs do not feel that STD94 defines a deterministic encoding, (perhaps they do understand that it does define requirements for others to create deterministic encodings).\n\nOver time, this seems to have resulted in many different deterministic encoding proposals, which blur the lines between \"Core Deterministic Encoding Requirements\" and \"Application-level Deterministic Representation\".\n\nMy preferred solution:\n\n- Update 8949 to make basic, preferred and deterministic clearly part of CBOR.\n- Choose terminology that is not nearly indistinguishable (Common vs Core) Deterministic Encoding (Requirements)\n- Keep the text on ALDR is a BCP, and anchor it to what is required for interop with STD 94.\n\n\n",
      "createdAt": "2025-04-02T15:53:31Z",
      "updatedAt": "2025-05-01T08:34:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2025-04-02, at 17:53, Orie Steele ***@***.***> wrote:\r\n> \r\n> \t\u2022 Choose terminology that is not nearly indistinguishable (Common vs Core) Deterministic Encoding (Requirements)\r\n\r\nI believe this problem can be completely solved by explaining it once.\r\n\r\nIf we really have to avoid the C, I found two synonyms of \u201ccommon\u201d:\r\n\r\n* universal\r\n* standard\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n\r\n",
          "createdAt": "2025-04-02T16:05:21Z",
          "updatedAt": "2025-04-02T16:05:21Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2025-04-02, at 17:53, Orie Steele ***@***.***> wrote:\r\n> \r\n> \t\u2022 Update 8949 to make basic, preferred and deterministic clearly part of CBOR.\r\n\r\n\u201cPreferred Serialization\" already is defined in 8949; there is no update.\r\n\r\nDeterministic is a mathematical property, CBOR doesn\u2019t define it.\r\nDeterministic encoding is, again, a property of serialization choices, not a specific set of such choices.\r\n8949 defines \u201ccore deterministic encoding requirements\u201d, which are OPTIONAL requirements to be picked by an application defining its deterministic encoding choices.\r\n\r\nPicking up all of them and selecting Rule 2 out of the bullet list in 4.2.2 yields a single, well-defined deterministic serialization or encoding, CDE.  This is what the BCP is about.\r\nIt does not change 8949.\r\n\r\n\u201cBasic Serialization\u201d just is a term for something that exists in 8949 (Second bullet of 4.2.1); one could argue that a new term updates the thing it is applied to, but that is a very weak argument.\r\n\r\nI\u2019m really having trouble following the argument here.\r\n\r\nHaving a single document that defines all of these, via reference or by new text, is exactly the point of the CDE draft; splitting it up over multiple documents is counterproductive.\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n\r\n",
          "createdAt": "2025-04-02T16:13:47Z",
          "updatedAt": "2025-04-02T16:13:47Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we have a better term than CDE.\n\nCan we close this?",
          "createdAt": "2025-05-01T08:34:34Z",
          "updatedAt": "2025-05-01T08:34:34Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJ8fYd86yK5ie",
      "title": "Clarify section 3 (CDE)",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/31",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "The only normative change from CDER to CDE is the addition of preferred serialization of big numbers. This is pretty hard to notice because that requirement is so encompassed by commentary, background and other text.\n\nA simple fix is to put the normative change in section 3.1 and the commentary in 3.2.\n\nI would much prefer this draft turn into a serialization draft with a lot of re writing, but I'm filing this issue because of the hard push for WGLC. I wouldn't want this draft to get published without some improvement to section 3.\n\n",
      "createdAt": "2025-04-11T16:51:33Z",
      "updatedAt": "2025-05-01T08:36:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "The (questionable) logic of RFC 8949 is to treat core requirements in Section (4.1 and) 4.2, and leave the tag-related requirements with the tags.  Since we use tags to represent bignums, the relevant specification text for tags 2 and 3 is in 3.4.3.\n\nThere is no normative change.\n\n(We can still mention the place where the text is in 8949 in CDE's section 3.1/3.2.)",
          "createdAt": "2025-04-13T09:50:51Z",
          "updatedAt": "2025-04-13T09:50:51Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "Assuming agreement that there's no normative change, that makes CDE and CDER pretty much the same. This rename (IMO) seems strange and confusing even given the email discussion about the helping a confused SDO with determinism.\n\nI know this is a bit radical, but can't we just drop the term \"CDE\" and go back to CDER so we don't have two names for the same thing. Seems like we can find another way to help the confused SDO.",
          "createdAt": "2025-04-30T06:26:15Z",
          "updatedAt": "2025-04-30T06:26:15Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "The point of giving the encoding a name is to go beyond the pick-your-variant set of requirements language of RFC 8949.\nYou are essentially proposing to introduce the new name CDER (which is not used in 8949) instead of CDE (which points to the BCP and has all the details SDOs and other users need).\n\nWhat do you gain from trying to use the wrong name for the thing?\n(CDER also is confusing, as it sounds like ASN.1 DER and CER mixed.)",
          "createdAt": "2025-04-30T06:33:39Z",
          "updatedAt": "2025-04-30T06:33:39Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is no normative change.\n\nWell, there is normative text on NaN with non-zero payloads now.\nCDE simply is the whole solution, no longer the \"some assembly required\" common requirements kit.",
          "createdAt": "2025-04-30T06:34:52Z",
          "updatedAt": "2025-04-30T06:34:52Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "We should not \"just drop the term \"CDE\" and go back to \"Core Deterministic Encoding Requirements\" or even introduce a confusing abbreviation for the latter.\n\nCan we close this now?\n",
          "createdAt": "2025-05-01T08:36:06Z",
          "updatedAt": "2025-05-01T08:36:06Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJ8fYd86zH9Ng",
      "title": "Deterministic serialization for tags 0, 1, 4, 5, 36, 257",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/32",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "Deterministic serialization is specified for tags 2, 3. It is inconsistent to not specify deterministic encoding for the above mentioned tags.\n\nI believe the tags not mentioned (e.g., 6, 7,... ) have no variability at the data model level so they are inherently deterministic.",
      "createdAt": "2025-04-18T15:42:34Z",
      "updatedAt": "2025-05-01T08:39:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know what tags 6 or 7 are (if cbor-packed gets 6, it is a nice example of not *wanting* to do deterministic representation, because packers are deliberately unspecified).\nThe tag numbers of the title seem to be a duplicate of #26.\n\nLet's continue any discussion needed there and close this duplicate.\n",
          "createdAt": "2025-05-01T08:39:39Z",
          "updatedAt": "2025-05-01T08:39:39Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOJ8fYd8602mTA",
      "title": "Floating-point clarifications really apply to preferred/basic serialization",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/issues/33",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think we should preserve the layering of CDER/CDE over basic/preferred where the only difference between the two is map sorting.\n\nThat implies all the clarifications on floating-point should be for basic/preferred serialization, not for CDER/CDE. \n\nA possible solution is to move those clarifications out of section 3 and into section 2. \n\nSome of the other discussion on floating-point is general high-level commentary and maybe can stay in section 3; NaN handling is the most obvious thing to be applied to preferred/basic serialization.\n",
      "createdAt": "2025-05-01T16:26:11Z",
      "updatedAt": "2025-05-03T12:10:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "See also: <https://mailarchive.ietf.org/arch/msg/cbor/Mm4iUMOLWc3F4aRWVgRyjdy98xc>\n",
          "createdAt": "2025-05-03T12:10:20Z",
          "updatedAt": "2025-05-03T12:10:20Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "PR_kwDOJ8fYd85jg4_G",
      "title": "Prepare -01",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/5",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* b850713 Add some security considerations\r\n* 0c91f68 Further clarifications\r\n* 4731cab Clarify representation of NaNs\r\n* 2190787 RECOMMENDS is not an RFC 2119 keyword\r\n* 45bdbdc Do section references into STD documents as pioneered in RFC 9485\r\n* cf3b06f Remove reference to I-D.bormann-cbor-dcbor\r\n",
      "createdAt": "2024-01-08T20:22:42Z",
      "updatedAt": "2024-01-08T20:23:37Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "8b29daf1dd4fca2098b3579b594755f538302506",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "prepare-01",
      "headRefOid": "b8507139bd5ce994446b3bd9d914c42168ecb727",
      "closedAt": "2024-01-08T20:23:37Z",
      "mergedAt": "2024-01-08T20:23:37Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "f93dd82df8d813506329995a4527749aa990c3f1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOJ8fYd85og4Is",
      "title": "Add proposed \"Implementers' Checklists\" Appendix",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/7",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-03T15:13:32Z",
      "updatedAt": "2024-03-03T19:44:22Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "1f0644ea5ca4a7c24267b3b40c585b1566e60a60",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "implementer-checklists",
      "headRefOid": "1f34190ae6d17106d0ec8df499c4f4bb29f92840",
      "closedAt": "2024-03-03T19:44:22Z",
      "mergedAt": "2024-03-03T19:44:22Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "8d4d3064774695856a166b6409b53a6c19cad14d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ8fYd85yBwgG",
          "commit": {
            "abbreviatedOid": "61b2b65"
          },
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Hi Carsten, looks generally good. Thank you kindly for including. I made some comments, but am fine with merging as is.",
          "createdAt": "2024-03-03T19:00:14Z",
          "updatedAt": "2024-03-03T19:30:34Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Type 7 described in 8949 is deterministic without further specification. In particular, the text for simple values requires shortest-form. That's the reason I said all but type 7 and didn't call out an exemption for floats.\r\n\r\nBut, yes in the obvious implementation, the exception is floats.\r\n\r\nI'm fine either way with the text.",
              "createdAt": "2024-03-03T19:00:14Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            },
            {
              "originalPosition": 24,
              "body": "Duplicate sentence.",
              "createdAt": "2024-03-03T19:02:19Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            },
            {
              "originalPosition": 34,
              "body": "I would remove \"for instance\". That text in 3.1 is _the_ normative unequivocal statement that duplicate map keys are not allowed. I kind of wish that text in 8949 was stronger.\r\n\r\nUnderstand that some decoders might not detect this and that we have to allow such decoders, but that doesn't change the hard requirement that duplicate map keys are never allowed, right?",
              "createdAt": "2024-03-03T19:10:28Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            },
            {
              "originalPosition": 55,
              "body": "The text \"support\" is kind of being used as a form of 2119 SHOULD here. I'd much prefer saying decoders MAY support checking.  I don't think it is a SHOULD and would prefer to stick with 2119 terminology.",
              "createdAt": "2024-03-03T19:22:36Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            },
            {
              "originalPosition": 138,
              "body": "I like this wording. I was trying to figure out something like this myself.",
              "createdAt": "2024-03-03T19:23:48Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            },
            {
              "originalPosition": 53,
              "body": "But, it doesn't negate the main benefit of Preferred which is interoperability nor the main benefit of CDE which is determinism.\r\n\r\nHaving spent a year plus trying to understand benefit and negatives of stuff in COSE and HPKE, I'd much prefer explicit statement of negatives and benefits.",
              "createdAt": "2024-03-03T19:29:16Z",
              "updatedAt": "2024-03-03T19:30:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB5vg",
          "commit": {
            "abbreviatedOid": "61b2b65"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T19:34:42Z",
          "updatedAt": "2024-03-03T19:34:42Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Yes!  That is the point...  We really mean this.",
              "createdAt": "2024-03-03T19:34:42Z",
              "updatedAt": "2024-03-03T19:34:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB50O",
          "commit": {
            "abbreviatedOid": "61b2b65"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T19:36:45Z",
          "updatedAt": "2024-03-03T19:36:45Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Correct, at least if you want to have valid encoded data items.\r\nRemoved the \"for instance\", but there are of course other places in 8949 that add information to this.\r\nBut citing them all here does not make sense, indeed.\r\n",
              "createdAt": "2024-03-03T19:36:45Z",
              "updatedAt": "2024-03-03T19:36:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB53A",
          "commit": {
            "abbreviatedOid": "61b2b65"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T19:38:03Z",
          "updatedAt": "2024-03-03T19:38:03Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "This is really a \"truth of advertising\" statement, not a SHOULD.\r\nSo it is phrased as a factual \"need to\".\r\n",
              "createdAt": "2024-03-03T19:38:03Z",
              "updatedAt": "2024-03-03T19:38:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB57u",
          "commit": {
            "abbreviatedOid": "61b2b65"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T19:40:07Z",
          "updatedAt": "2024-03-03T19:40:08Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Not checking removes some security properties.\r\n\r\nSection 5 (security considerations):\r\n\r\n```\r\nHowever, this effect only accrues if the decoder actually checks that\r\ndeterministic encoding was applied correctly.\r\n```\r\n\r\nThis is just restated here...",
              "createdAt": "2024-03-03T19:40:07Z",
              "updatedAt": "2024-03-03T19:40:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOJ8fYd85ohQ9f",
      "title": "Use \"preferred serialization\" consistently.",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/9",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Close #8",
      "createdAt": "2024-03-03T19:49:14Z",
      "updatedAt": "2024-03-03T20:17:52Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "8d4d3064774695856a166b6409b53a6c19cad14d",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "preferred-serialization",
      "headRefOid": "f60ce32c7ff107582741691089eac39dbce032ba",
      "closedAt": "2024-03-03T20:17:52Z",
      "mergedAt": "2024-03-03T20:17:52Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "ac3c2e7bef3887b55c35e7e6bf0e3f97f4aab710"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ8fYd85yB6dv",
          "commit": {
            "abbreviatedOid": "3a270c7"
          },
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T19:55:19Z",
          "updatedAt": "2024-03-03T19:56:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Isn't this section 4.1 of 8949?  I assumed preferred serialization is capitalized here because it is the title of the section.",
              "createdAt": "2024-03-03T19:55:19Z",
              "updatedAt": "2024-03-03T19:56:28Z"
            },
            {
              "originalPosition": 5,
              "body": "I think I'd make this not capitalized.",
              "createdAt": "2024-03-03T19:56:05Z",
              "updatedAt": "2024-03-03T19:56:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB6v4",
          "commit": {
            "abbreviatedOid": "3a270c7"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T20:03:08Z",
          "updatedAt": "2024-03-03T20:03:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This was specifically about encoding of integers, 3.4.3:\r\n\r\n```\r\nThe preferred serialization of an integer that can\r\n   be represented using major type 0 or 1 is to encode it this way\r\n   instead of as a bignum (which means that the empty string never\r\n   occurs in a bignum when using preferred serialization)\r\n```\r\n\r\nFixed the case, added \"for all integers\".",
              "createdAt": "2024-03-03T20:03:08Z",
              "updatedAt": "2024-03-03T20:03:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB7PK",
          "commit": {
            "abbreviatedOid": "3a270c7"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T20:14:13Z",
          "updatedAt": "2024-03-03T20:14:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sorry, emacs global substitute keeps the case; fixed this below.\r\nNow mostly downcased.",
              "createdAt": "2024-03-03T20:14:13Z",
              "updatedAt": "2024-03-03T20:14:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd85yB7Wy",
          "commit": {
            "abbreviatedOid": "f60ce32"
          },
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-03T20:17:08Z",
          "updatedAt": "2024-03-03T20:17:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOJ8fYd85yRyds",
      "title": "Separate motivation (for the Introduction) and what an implementer needs to do",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/10",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "to be closed"
      ],
      "body": "Simplify Abstract; Move motivation to Introduction",
      "createdAt": "2024-06-12T19:22:23Z",
      "updatedAt": "2025-05-01T08:40:20Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "2bbc1a1a6c706f5c33e5e779df65d5b811c2f322",
      "headRepository": "rohanmahy/draft-ietf-cbor-cde",
      "headRefName": "rohan/intro",
      "headRefOid": "217ded4bd47176b7e9b165f698d9afadd28cdcdb",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!  I think I like what I'm seeing, but some assembly is still required.\r\nUnfortunately, I ran out of time integrating this change; I plan to have this as part of -04 on 2024-07-21.",
          "createdAt": "2024-07-08T23:47:58Z",
          "updatedAt": "2024-07-08T23:47:58Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "MEMBER",
          "body": "Please revisit whether that is still current (a lot changed in this document, @cabo mentioned in today's interim that it is probably overtaken by events)",
          "createdAt": "2025-03-05T15:13:21Z",
          "updatedAt": "2025-03-05T15:13:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOJ8fYd85zQWJX",
      "title": "Add NaN Appendix",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/11",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-22T18:05:21Z",
      "updatedAt": "2024-06-22T18:21:36Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "2bbc1a1a6c706f5c33e5e779df65d5b811c2f322",
      "headRepository": "laurencelundblade/draft-ietf-cbor-cde",
      "headRefName": "NaNPayload",
      "headRefOid": "af61b4885a89b19f523b4b32d92d8f7c9e4c55c9",
      "closedAt": "2024-06-22T18:08:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "Oops. Not ready yet.",
          "createdAt": "2024-06-22T18:08:57Z",
          "updatedAt": "2024-06-22T18:08:57Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "You can keep it as a draft PR",
          "createdAt": "2024-06-22T18:21:34Z",
          "updatedAt": "2024-06-22T18:21:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOJ8fYd850neV8",
      "title": "Clarify concept of a CDE decoder and what it MUST do",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/12",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-07T16:54:42Z",
      "updatedAt": "2024-07-08T23:40:52Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "2bbc1a1a6c706f5c33e5e779df65d5b811c2f322",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "cde-decoder",
      "headRefOid": "742f49e4c1a54751d1d02fb18d1464db90317f7c",
      "closedAt": "2024-07-08T23:40:52Z",
      "mergedAt": "2024-07-08T23:40:52Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "20b187cf85fd317042f75bd3129b4241d9476325"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOJ8fYd850nvaA",
      "title": "NaN appendix",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/13",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It takes week or so to implement basic CBOR integer and float encoding. I\u2019m not as smart as some here, but I get by\u2026 It took me many many months to figure out NaN payloads. I\u2019ve put what I learned in a NaN Appendix to the CDE draft to save others these months.\r\n\r\nIt\u2019s a fairly long addition, but it seems worthwhile to me to cover the details explicitly. It\u2019s an appendix, not the main document, which signals to the reader that they don\u2019t have to read it.\r\n\r\nIt makes a recommendation that protocol designers not use NaN payloads because there are better ways to accomplish the same.",
      "createdAt": "2024-07-07T21:06:24Z",
      "updatedAt": "2024-11-03T16:15:47Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "2bbc1a1a6c706f5c33e5e779df65d5b811c2f322",
      "headRepository": "laurencelundblade/draft-ietf-cbor-cde",
      "headRefName": "NaNAppendix",
      "headRefOid": "0dded2b7285049bc2c7b1710055367daaec099ee",
      "closedAt": "2024-11-03T16:15:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!  I think the most valuable part here is the table at the end.\r\nThe explanation probably should first explain that CBOR supports IEEE 754, what a NaN is, that a NaN always has a payload, and which payload values aren't available because they would mean something different than a NaN.  A quick discussion of the quiet/signaling bit, the fact that IEEE 754 doesn't define it, but there is a de facto standard needs to follow, and then we can introduce the \"basic\" NaN with sign 0, quiet bit 1, all other payload bits zero.  The reason why some applications are not using `foo = float / null` or `foo = float / payload` where payload can be anything but float.  Then a quick discussion of implementation considerations for preferred serialization, including the weirdness that two NaNs do not compare equal in most platforms, even if they are equal wrt to their payloads.\r\n\r\nI'm not sure this shouldn't be a separate draft, to which CDE could refer for information.\r\nIt's night here already, but I could turn your input and the above outline into a draft about NaN and CBOR.",
          "createdAt": "2024-07-07T21:22:40Z",
          "updatedAt": "2024-07-07T21:22:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "<https://mailarchive.ietf.org/arch/msg/cbor/KA7ma_UIESnM11SODvmoium9Uqc>",
          "createdAt": "2024-07-07T21:34:54Z",
          "updatedAt": "2024-07-07T21:34:54Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Now became part of https://datatracker.ietf.org/doc/draft-bormann-cbor-numbers/\r\nStill needs to be referenced properly; ran out of time.\r\n",
          "createdAt": "2024-07-08T23:43:14Z",
          "updatedAt": "2024-07-08T23:43:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOJ8fYd851jZ7-",
      "title": "Application profile appendix",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/15",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Move the application profile section to an appendix.\r\n\r\nClarify the relationship between CDE and application\r\nprotocols/profiles some more.\r\nAdd \"Structure of This Document\".\r\n",
      "createdAt": "2024-07-16T19:23:37Z",
      "updatedAt": "2024-07-21T11:37:01Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "20b187cf85fd317042f75bd3129b4241d9476325",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "application-profile-appendix",
      "headRefOid": "fc56cc475f806d3fc82bec19b9d83e6672335f53",
      "closedAt": "2024-07-21T11:37:01Z",
      "mergedAt": "2024-07-21T11:37:01Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "55cfa915053508f2c000dfb13c49e9855e1beb38"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOJ8fYd852AzBW",
      "title": "Clarify120: CDE clarifications for IETF 120",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/16",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-21T12:37:24Z",
      "updatedAt": "2024-07-21T12:43:53Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "55cfa915053508f2c000dfb13c49e9855e1beb38",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "clarify120",
      "headRefOid": "a9b1067434d9dfd8a71c778c24c3c0c5db027421",
      "closedAt": "2024-07-21T12:43:52Z",
      "mergedAt": "2024-07-21T12:43:52Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "52c20a375fd36bffd5d704f49fed3567492a4a65"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOJ8fYd852fKCC",
      "title": "Fix #17, address #18, add \"Basic Serialization\"",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/19",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Intended to replace draft-lundblade-cbor-cie-00.txt",
      "createdAt": "2024-07-25T16:03:46Z",
      "updatedAt": "2024-07-25T23:48:01Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "52c20a375fd36bffd5d704f49fed3567492a4a65",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "basic-serialization",
      "headRefOid": "7a74d2e658b66db58d076dd5702d60f69bf2cdfb",
      "closedAt": "2024-07-25T23:48:01Z",
      "mergedAt": "2024-07-25T23:48:01Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "374be6737dff5e4fdf6c7cfad3b20a0ceea891fc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 21,
      "id": "PR_kwDOJ8fYd85-zqBJ",
      "title": "Prepare the 2024-10-16 interim.",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/21",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-16T10:29:47Z",
      "updatedAt": "2024-11-03T16:15:46Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "5cb7ae377cd7ab3c673ff72c0c1573b726a8b028",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "interim-2024-10-16",
      "headRefOid": "ca14c3f8a716e3225a852c7f2930a6b271c54fc8",
      "closedAt": "2024-11-03T16:15:46Z",
      "mergedAt": "2024-11-03T16:15:46Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "b468eb16f12a6ab0e6e25c59e0ae8e2eae15219f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "PR_kwDOJ8fYd86HC88a",
      "title": "Avoid using the contentious word \"profile\" except for CDE itself.",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/23",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-08T09:38:05Z",
      "updatedAt": "2025-01-21T19:47:31Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "b468eb16f12a6ab0e6e25c59e0ae8e2eae15219f",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "avoid-profile",
      "headRefOid": "e09c6c93b5203a6ac9d494ae4dfed39d5b1afbc8",
      "closedAt": "2025-01-21T19:47:31Z",
      "mergedAt": "2025-01-21T19:47:31Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "e3a91df56b057027f6c15bc9b69294086d0b38ef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ8fYd86XOy0a",
          "commit": {
            "abbreviatedOid": "6325c7f"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-08T14:04:21Z",
          "updatedAt": "2025-01-08T14:04:21Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "CWT might be a stronger reference if you could use it to explain ALDR",
              "createdAt": "2025-01-08T14:04:21Z",
              "updatedAt": "2025-01-08T14:04:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOJ8fYd86J53_T",
      "title": "Add new section 2 about encoding choices; fix up ALDR explanations",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/24",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-03T21:11:31Z",
      "updatedAt": "2025-02-10T10:23:44Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "9ca66321203435f571e7b6999e6eafe12d5d7149",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "encoding-choices",
      "headRefOid": "ace1bb1944822bfdf207c0bd1e47bcc62f6f4103",
      "closedAt": "2025-02-10T10:23:44Z",
      "mergedAt": "2025-02-10T10:23:43Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "c84b2c32714be92d88f903f7b952db107fb2b38d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ8fYd86bFrQ4",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks, I like what I read :) some comments inline.",
          "createdAt": "2025-02-07T14:54:28Z",
          "updatedAt": "2025-02-07T15:49:10Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nIn many cases, CBOR provides more than one way to encode a data item,\r\ni.e., serialize it into a sequence of bytes.\r\n```",
              "createdAt": "2025-02-07T14:54:28Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nIn general, there is no single perfect encoding choice that is optimal for all\r\n```",
              "createdAt": "2025-02-07T15:17:21Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nHaving predefined sets of such choices is a useful way to reduce\r\n```",
              "createdAt": "2025-02-07T15:17:52Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nThese constraints still allow some variation. In particular, there is\r\n```",
              "createdAt": "2025-02-07T15:19:37Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\ndefining a deterministic (namely, lexicographic) order for the keys in a map.\r\n```",
              "createdAt": "2025-02-07T15:20:31Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 124,
              "body": "I like!",
              "createdAt": "2025-02-07T15:25:46Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 129,
              "body": "I'm not sure I can parse this. How would an application \"generate (...) CBOR data items\"? Shouldn't applications be concerned with application data items and not CBOR data items?\r\n\r\nI guess you want to allude to problems such as integer/float equivalence on the application layer, but I can't match that to the sentence as is.\r\n\r\nIsn't it then more about the application handling different (received) CBOR data items as the same application data item?",
              "createdAt": "2025-02-07T15:31:12Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\napplication-level representation rules of course can still be useful\r\n```",
              "createdAt": "2025-02-07T15:31:30Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 135,
              "body": "```suggestion\r\nto amplify the benefits of Preferred or Basic Serialization,\r\nbut would not fall into the category of ALDR rules.\r\n```\r\n\r\nCouldn't we instead loosen the term ALDR (to ALR?) to encompass those, too? The differentiation between CBOR layer encoding rules and application-layer encoding rules would also be present for those cases, and would benefit from a term, too, I'd say.",
              "createdAt": "2025-02-07T15:34:51Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\nthe application defining rules for ALDR (see also {{aldr}}).\r\n```\r\n(not sure about the right hyperlink syntax)",
              "createdAt": "2025-02-07T15:47:49Z",
              "updatedAt": "2025-02-07T15:49:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bHS1F",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-07T17:28:27Z",
          "updatedAt": "2025-02-07T17:28:28Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Hmm, you don't order the keys, you order the entries (by their keys).\r\nAlso, I tried to point out that we need to agree on an order (so that in the end gives a deterministic result, of course, but the agreement was the point).",
              "createdAt": "2025-02-07T17:28:28Z",
              "updatedAt": "2025-02-07T17:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bHcAA",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-07T17:45:09Z",
          "updatedAt": "2025-02-07T17:45:09Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Well, something needs to go from the application's information model to the CBOR generic data model.  Generally, this needs to be part of the application -- generally not the business end, but somewhere on the belly.  The onus on being deterministic is on the originating application.  To deal with bugs and attacks, the ingesting application should then check that this is done properly.",
              "createdAt": "2025-02-07T17:45:09Z",
              "updatedAt": "2025-02-07T17:45:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bHeVC",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-07T17:49:21Z",
          "updatedAt": "2025-02-07T17:49:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "The representation of application data in CBOR data items generally is governed by rules, which we could indeed term ALRs.  But this is so obvious that there is little point do have a term for that.\r\n\r\nThe need for ALDRs, in contrast, is specific to deterministic representation, and it can be surprising if you haven't done deterministic representation of application data before.\r\nSo it is a good thing to point this out and to also relieve the reader from the potental misunderstanding that ALDR needs to be put into CDE, because all deterministic encoding is put there.\r\n",
              "createdAt": "2025-02-07T17:49:21Z",
              "updatedAt": "2025-02-07T17:49:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bSb_q",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-10T10:16:59Z",
          "updatedAt": "2025-02-10T10:16:59Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "ACK :)",
              "createdAt": "2025-02-10T10:16:59Z",
              "updatedAt": "2025-02-10T10:16:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bSdxC",
          "commit": {
            "abbreviatedOid": "37c0ea1"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-10T10:20:00Z",
          "updatedAt": "2025-02-10T10:20:00Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Okay, makes sense. Thanks for re-explaining!",
              "createdAt": "2025-02-10T10:20:00Z",
              "updatedAt": "2025-02-10T10:20:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ8fYd86bSeI5",
          "commit": {
            "abbreviatedOid": "ace1bb1"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-10T10:20:38Z",
          "updatedAt": "2025-02-10T10:20:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOJ8fYd86P6IHO",
      "title": "Describe information model, data model and serialization",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/27",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A big motivation for this is that it would have taken six months off some of the email list discussions for me.\r\n\r\nAlso, JSON doesn't have the separation between data mode and serialization, so it might not be widely understood.\r\n\r\nAlso, understanding this is an under pinning to understand why serialization is the way it is.",
      "createdAt": "2025-03-24T17:27:06Z",
      "updatedAt": "2025-04-13T09:51:41Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "2cacb744ca196fce05070b8e343747c7b3b5b994",
      "headRepository": "laurencelundblade/draft-ietf-cbor-cde",
      "headRefName": "models",
      "headRefOid": "f94f874a49f64c95c5ebb22c73fa5ea54fe0facc",
      "closedAt": "2025-04-13T09:51:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice!\r\nI started editing this and didn't want to edit on your account, so I forked the branch (now #28).\r\nIt is less clear to me what you wanted to say in the last two paragraphs, so I left them unedited for now.\r\n(I mostly transposed the table so it better shows the layering, and aligned same of the statements with our current terminology and certain facts about JSON.)",
          "createdAt": "2025-03-26T16:53:33Z",
          "updatedAt": "2025-03-26T16:53:33Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there anything left that hasn't been covered by #28?",
          "createdAt": "2025-04-02T16:39:12Z",
          "updatedAt": "2025-04-02T16:39:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this now as overtaken by events.",
          "createdAt": "2025-04-13T09:51:41Z",
          "updatedAt": "2025-04-13T09:51:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOJ8fYd86QPk00",
      "title": "Describe information model, data model and serialization (edit of #27)",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/28",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-26T16:50:39Z",
      "updatedAt": "2025-04-02T15:52:53Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "a9670a7ed020dbba0d7272aa488a502668627986",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "models-edit",
      "headRefOid": "f93126b42cc8532b57438075c63af8569c580f02",
      "closedAt": "2025-04-02T15:52:52Z",
      "mergedAt": "2025-04-02T15:52:52Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "653a6effaa83665bd1accb4bcd25295729542531"
      },
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "Trying to get clear how we characterize data model in CBOR vs JSON. When I ask ChatGPT, it says JSON doesn't have a separate data model (I ask ChatGPT because I don't work with JSON much).\r\n\r\nDo you think this is true: the variation in JSON is for ease of use by humans; the variation in CBOR is for ease of implementation in constrained environments? \r\n\r\nThat's not wording for the document, just to understand.\r\n\r\n",
          "createdAt": "2025-03-26T19:15:40Z",
          "updatedAt": "2025-03-26T19:15:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there was any conscious design on this going into JSON.  \r\nWhat we have there is pretty much a subset of JavaScript; whatever variation JavaScript had at the time went into JSON. \r\nExcept comments.\r\n\r\nIn CBOR, the early approach was to be deterministic (at least to the level that is now called \"preferred\") from the outset. \r\nThen there were considerations about implementations that simply fill in a binary \"form\" to send some data; these can't send \"preferred\".  \r\nAnd indefinite length was added as another variation, creating the need to have another term on the way to fully deterministic, which we now call \"basic\".\r\n\r\nOn the separation between serialization and data model: JSON tried to be a \"format\" only, i.e., a syntax, a grammar, with semantics that were only implied.  This is not the right way to do it, but this is very visible in ECMA 404 and even in the JSON RFCs (only Section 1 even mentions that there might be data with certain types and not just JSON texts).  This is what eventually made RFC 7493 necessary, I-JSON, which of course only could restrict the generic data model to what was interoperable in practice, dominated by JavaScript implementation practices.\r\n\r\nCBOR was built on a much deeper understanding of the issue.\r\nHowever, we hadn't had a strong requirement for deterministic representation and therefore only added deterministic encoding as an afterthought.  \r\nWe also were still struggling with the int/float issue and probably had a more dCBOR-like view (actually informed by the programming language Scheme) on this when RFC 7049 was finalized.  \r\nIn the seven years between 7049 and 8949, we got very strong feedback that int/float equivalence was not for everyone, so we dialed that back in the STD; the two are now clearly separate but can be integrated again [at the ALDR level (as dCBOR does)].  \r\nThe wording in 4.2.2 wasn't great though, and it took the dCBOR discussions and CDE to actually find the terms we needed here.",
          "createdAt": "2025-03-26T19:41:49Z",
          "updatedAt": "2025-03-26T19:41:49Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "NONE",
          "body": "Thx.\r\n\r\nMaybe this: JSON decoders must accept all encoding variants (e.g., 1, 1.000...); that is not true of CBOR so as to accommodate constrained environments. CBOR also allows more variance than JSON (e.g. indefinite-lengths) also for constrained environments.",
          "createdAt": "2025-03-26T20:18:30Z",
          "updatedAt": "2025-03-26T20:18:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJ8fYd86jGyOy",
          "commit": {
            "abbreviatedOid": "f93126b"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-02T14:22:28Z",
          "updatedAt": "2025-04-02T14:22:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOJ8fYd86U0qmr",
      "title": "Close #33",
      "url": "https://github.com/cbor-wg/draft-ietf-cbor-cde/pull/34",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 3: Don't try to hide the fact that most clarifications in Section 3 are about Preferred Serialization; explain why these are needed specifically for CDE.\r\n\r\nAttendant editorial fixes:\r\n\r\n* s/CDE decoder/CDE-checking decoder/\r\n* Always capitalize ___ed Serialization\r\n* reduce use of \"shortest\" in examples when we mean preferred",
      "createdAt": "2025-05-03T12:14:34Z",
      "updatedAt": "2025-05-10T18:44:27Z",
      "baseRepository": "cbor-wg/draft-ietf-cbor-cde",
      "baseRefName": "main",
      "baseRefOid": "653a6effaa83665bd1accb4bcd25295729542531",
      "headRepository": "cbor-wg/draft-ietf-cbor-cde",
      "headRefName": "section3",
      "headRefOid": "4db816fee93f71c2e51d3610629cc502dad3dace",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}